#!/bin/R-3.4.3


#### code to make SOX10 KD cell line, MR activity heatmap (Supp Figs)
#
# code from ipynb 20190723 
 
# b06x-cnt2
# screen name: chip

# request interactive session - small!
# qsub -I -l walltime=2:00:00,mem=8g,nodes=1
# load R v3.4.3: module load R-bundle/20171215-foss-2017a-R-3.4.3

#############################################
#
# setup
#
#############################################
# define #cores to parallelise over; set based on #cores requested for job
n.cores <- 1

# load libs for analysis:
suppressMessages(library(viridis))
# load Epik 
#suppressMessages( library(epik) )
# for differential binding analysis
#suppressMessages( library(DiffBind) )
# to install if needed:
#source("https://bioconductor.org/biocLite.R")
#biocLite("EnsDb.Hsapiens.v75")
#
# annotation libs:
#suppressMessages( library(EnsDb.Hsapiens.v75) )
#suppressMessages( library(TxDb.Hsapiens.UCSC.hg19.knownGene) )
suppressMessages( library(ggplot2) )
suppressMessages( library(org.Hs.eg.db) )
#suppressMessages( library(reactome.db) )
# ChIP analysis:
#suppressMessages( library(ChIPpeakAnno) )
#library(DiffBind)
# plotting and heatmaps
suppressMessages( library(RColorBrewer) )
suppressMessages( library(EnrichedHeatmap) )
suppressMessages( library(circlize) )
# parallelise some data loading functions
#suppressMessages( library(parallel) )
# RTN
suppressMessages(library(RTN))

# load common HIPO016 analysis code...
source("/home/fletcher/git_repos/gbm-master-regulators/gbm_hipo016_common.R")

# set working dir
dir.working <- "/icgc/dkfzlsdf/analysis/hipo/hipo_016/analysis/chipseq_sox10_kd/"
setwd(dir.working)

#############################################
# load Renv
#############################################
load("2019-03-08_end_Renv.Rdata")

#############################################
# VIPER: generate regulons
#############################################
library(viper)
# annotation libraries for VIPER analysis (mapping microarray probe IDs)
suppressMessages(library(hgu133a.db))
suppressMessages(library(hgu133plus2.db))

# load RTN TNI objs
load("/icgc/dkfzlsdf/analysis/hipo/hipo_016/rtn/results_gbm_repro/2017-12-19_RTN_GBM_processed_TNI_test.Rdata")
#load("/icgc/dkfzlsdf/analysis/hipo/hipo_016/rtn/results_gbm_repro/2017-12-20_RTN_GBM_processed_TNI_validation.Rdata")

# define MRs for analysis: 
# load MR results: 
# use new table based on definitions in email received 20190429 from Carl, saved in analysis dir
path <- "/icgc/dkfzlsdf/analysis/hipo/hipo_016/analysis/scRNAseq_Darmanis_2017/CRC_MRs_20190429.csv"
df.mrs <- read.csv(path, stringsAsFactors=F)
# check dims:
dim(df.mrs) # should be 37 MRs with 2 columns (symbol + subtype)

# define vector of MRs to analyse: keep all MES/RTK_I
mrs <- df.mrs$symbol[ df.mrs$subtype %in% c("MES","RTK_I") ]
length(mrs) # how many? should be: 19

##############################
# test/network A:
#
# already have the .adj file so just load directly:
##############################
options(stringsAsFactors=T) # need to set to T otherwise aracne2regulon() breaks!

# get expression matrix
exp.test <- tni.get(rtni.test,what='gexp')
# fix rownames = map from probe ID to symbol
symb.row <- convertIDs(rownames(exp.test),from='PROBEID',to='SYMBOL',hgu133a.db,ifMultiple = 'useFirst')
rownames(exp.test) <- symb.row

# generate regulon object
reg.viper.test <- aracne2regulon("/icgc/dkfzlsdf/analysis/hipo/hipo_016/analysis/chipseq_sox10_kd/GBM_networkA_ARACNe_CRC_MES-RTK_I_MRs.adj", exp.test, format='3col')

############################################################
#
# load cell line GX data from NEW analysis, combine by rownames, pass to VIPER to infer CRC MR activity
#
############################################################
# as we need the per-sample data:
# load the limma analysis Renv from the LN229 SOX10 KD microarray analysis (see sox10_kd_limma_analysis.Rscript)
path.limma.renv <- "/icgc/dkfzlsdf/analysis/hipo/hipo_016/analysis/SOX10_KD_microarrays/2019-07-20_analysis/2019-07-20_SOX10_KD_limma_analysis_Renv.Rdata"
load(path.limma.renv)

# extract GX values!
#
# have multiple experiments; filtered GX matrix in gx.filt.affy: 
# 1. Affy arrays on LN229
# 2. Affy arrays on ZH487 - with 2 reps per condition
###
# average the 2 ZH reps and then run analysis
###
# GX matrix already has sample names in colnames; make a copy and then average the reps
mat.gx <- gx.filt.affy
# map gene symbols to rownames
rownames(mat.gx) <- array.anno.affy$symbol[ match(rownames(mat.gx),array.anno.affy$probe_id) ]
#
# average the 2 reps per condition for the ZH:
# ZH samples (2 reps of n=5) in cols 6-10 and 11-15, ordered by condition; so average out each
mat.gx.2 <- cbind( mat.gx,
                  rowMeans( mat.gx[ , grep(pattern="ZH487_mock", x=colnames(mat.gx)) ] ),
                  rowMeans( mat.gx[ , grep(pattern="ZH487_NT", x=colnames(mat.gx)) ] ),
                  rowMeans( mat.gx[ , grep(pattern="ZH487_shSOX10_1", x=colnames(mat.gx)) ] ),
                  rowMeans( mat.gx[ , grep(pattern="ZH487_shSOX10_2", x=colnames(mat.gx)) ] ),
                  rowMeans( mat.gx[ , grep(pattern="ZH487_shSOX10_3", x=colnames(mat.gx)) ] )
                 )
# drop cols 6-15, add in colnames for the new cols of means
mat.gx <- mat.gx.2[,-(6:15)]
colnames(mat.gx)[6:10] <- c("ZH487_mock", "ZH487_NT","ZH487_shSOX10_1","ZH487_shSOX10_2","ZH487_shSOX10_3")

##############################
# run viper analysis
#
# run on the two matrices separately, combine after
##############################
# as input expr matrix: use the cell line matrices above
timestamp()
viper.test <- viper( eset=mat.gx, regulon=reg.viper.test, minsize = 10, method='scale', verbose = FALSE, cores=n.cores)
timestamp()
#viper.validation.ln <- viper( eset=mat.gx.ln, regulon=reg.viper.validation, minsize = 10, method='scale', verbose = FALSE, cores=n.cores)
#viper.validation.zh <- viper( eset=mat.gx.zh, regulon=reg.viper.validation, minsize = 10, method='scale', verbose = FALSE, cores=n.cores)
#timestamp()
# well quick for small set here

# merge per network, by rownames:
#viper.test <- merge( viper.test.ln, viper.test.zh, by="row.names")
#viper.validation <- merge( viper.validation.ln, viper.validation.zh, by="row.names")
# move rownames col to, er, rownames and drop
#rownames(viper.test) <- viper.test[,"Row.names"]
#rownames(viper.validation) <- viper.validation[,"Row.names"]
#viper.test <- viper.test[,colnames(viper.test)!="Row.names"]
#viper.validation <- viper.validation[,colnames(viper.validation)!="Row.names"]

# generate heatmap annotation with cell line name and NT/KD status
# hardcoded based on what's in the columns:
top.anno <- columnAnnotation(
    df=data.frame(Cell_Line=c(rep("LN229",5), rep("ZH487",5)), 
                  Treatment=c(rep("NT",2),rep("KD",3),rep("NT",2),rep("KD",3))),
    col=list(Cell_Line=c(LN229="navy",ZH487="orange"), Treatment=c(NT="white",KD="black"))
)

##############################
# plot heatmaps for networks, separately
#
# perform column clustering manually on the non-SOX10 rows;
#
# take the SOX10 row and add it as a column annotation also (so it's not used in clustering)
##############################
# define hclust method: use ward.D2
hclust.method <- "ward.D2"

###############
# test:
###############
# filter the activity matrix for the non-SOX10 rows
viper.test.filt <- viper.test[ !(rownames(viper.test) %in% "SOX10"), ]

# heatmap colours:
# match blue-yellow palette of Viridis; use three colours to get the right shades to match the pseudotime plots
# as this is not present in R v3.4.3 need to define manually - run in 3.5.1 and get hte vector from there
#viridis(n=3, option="E")
cols.nes <- colorRamp2( breaks=c(min(viper.test.filt),0,max(viper.test.filt)), 
                       colors=c("#00204DFF","#7C7B78FF","#FFEA46FF") )

# generate col anno with SOX10 scores
options(stringsAsFactors=F) # need to set this so data.frame() in next call works (sigh!)
col.anno <- columnAnnotation(df=(data.frame(SOX10=viper.test["SOX10",])), col=list(SOX10=cols.nes),
                            show_annotation_name=TRUE, show_legend=FALSE, annotation_name_gp=gpar(fontsize=8)) 

# cluster cols:
# calculate distances of columns - work on transverse of filtered viper mat; use default euclidean distance
col.dist <- dist( t(viper.test.filt) )
# cluster based on distance matrix
col.clust <- as.dendrogram( hclust( col.dist, method=hclust.method ) )

# generate row annotation:
# subset the df.mrs for the rows present
df.mrs <- df.mrs[ df.mrs$symbol %in% rownames(viper.test.filt), ]
# this is ordered by MRs alphabetically by subtype: so reorder MR activity mat, then create anno
viper.test.filt <- viper.test.filt[ match(df.mrs$symbol, rownames(viper.test.filt)), ]
row.anno <- rowAnnotation( 
    df=data.frame(Subtype=df.mrs$subtype),
    col=list(Subtype=subtype.colours)
)

# generate heatmap object; don't cluster rows
h <- Heatmap(mat=as.matrix(viper.test.filt), col=cols.nes, name="VIPER NES", top_annotation=top.anno,
    column_names_gp = gpar(fontsize = 8), row_title=NULL, bottom_annotation=col.anno,
    clustering_method_rows="ward.D2", clustering_distance_rows="euclidean",
    cluster_columns=col.clust, cluster_rows=FALSE,
    #clustering_method_columns="ward.D2", clustering_distance_columns=function(x) as.dist(1-cor(t(x))),
    column_title_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 8), show_row_names=TRUE ) + row.anno
# output
outputname <- paste0(Sys.Date(), "_SOX10_ChIPseq_08_MES-RTK_I_CRC_MR_activity_netA_in_cell_line_microarrays.pdf")
pdf(outputname)
h
dev.off()